"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
require("reflect-metadata");
const fastest_validator_1 = __importDefault(require("fastest-validator"));
const lodash_1 = require("lodash");
const SCHEMA_KEY = Symbol("propertyMetadata");
const TYPE_KEY = Symbol("typeMetadata");
const COMPILE_KEY = Symbol("compileKey");
exports.validate = (obj) => {
    const validate = Reflect.getMetadata(COMPILE_KEY, obj.constructor);
    if (!validate) {
        throw new Error("Obj is missing complied validation method");
    }
    return validate(obj);
};
exports.validateOrReject = (obj) => __awaiter(void 0, void 0, void 0, function* () {
    const result = exports.validate(obj);
    if (result !== true) {
        throw result;
    }
    return true;
});
function getSchema(target) {
    return lodash_1.cloneDeep(Reflect.getMetadata(SCHEMA_KEY, target.prototype));
}
exports.getSchema = getSchema;
const updateSchema = (target, key, options) => {
    const s = lodash_1.cloneDeep(Reflect.getMetadata(SCHEMA_KEY, target) || {});
    s[key] = options;
    Reflect.defineMetadata(SCHEMA_KEY, s, target);
};
function Schema(strict = false, messages = {}) {
    return function _Schema(target) {
        updateSchema(target.prototype, "$$strict", strict);
        return class extends target {
            constructor(...args) {
                super(...args);
                const s = Reflect.getMetadata(SCHEMA_KEY, this) || {};
                const v = new fastest_validator_1.default({ messages });
                Reflect.defineMetadata(COMPILE_KEY, v.compile(s), target);
                return this;
            }
        };
    };
}
exports.Schema = Schema;
exports.decoratorFactory = (mandatory = {}, defaults = {}) => {
    return function (options) {
        return (target, key) => {
            updateSchema(target, key, Object.assign(Object.assign(Object.assign({}, defaults), (options || {})), mandatory));
        };
    };
};
exports.Field = exports.decoratorFactory({}, {});
exports.String = exports.decoratorFactory({ type: "string" }, { empty: false });
exports.Boolean = exports.decoratorFactory({ type: "boolean" });
exports.Number = exports.decoratorFactory({ type: "number" }, { convert: true });
exports.UUID = exports.decoratorFactory({ type: "uuid" });
exports.ObjectId = exports.decoratorFactory({ type: "string" }, { pattern: /^[a-f\d]{24}$/i });
exports.Email = exports.decoratorFactory({ type: "email" });
exports.Date = exports.decoratorFactory({ type: "date" });
exports.Enum = exports.decoratorFactory({ type: "enum" });
exports.Array = exports.decoratorFactory({ type: "array" });
function Nested(options) {
    return (target, key) => {
        const t = Reflect.getMetadata("design:type", target, key);
        Reflect.defineMetadata(TYPE_KEY, t, target, key);
        const props = Object.assign({}, getSchema(t));
        const strict = props.$$strict || false;
        delete props.$$strict;
        updateSchema(target, key, Object.assign(Object.assign({}, options), { props, strict, type: "object" }));
    };
}
exports.Nested = Nested;
function NestedArray(type, options) {
    return (target, key) => {
        const props = Object.assign({}, getSchema(type));
        const strict = props.$$strict || false;
        delete props.$$strict;
        Reflect.defineMetadata(TYPE_KEY, type, target, key);
        updateSchema(target, key, Object.assign(Object.assign({}, options), { type: "array", strict, items: { props, strict, type: "object" } }));
    };
}
exports.NestedArray = NestedArray;
function transform(obj) {
    const schema = getSchema(obj.constructor);
    const props = Object.keys(schema);
    props.forEach(prop => {
        if (!obj[prop]) {
            return;
        }
        if (schema[prop].type === "object") {
            const type = Reflect.getMetadata(TYPE_KEY, obj, prop);
            obj[prop] = Object.assign(new type(obj[prop]), obj[prop]);
            transform(obj[prop]);
        }
        if (schema[prop].type === "array") {
            const type = Reflect.getMetadata(TYPE_KEY, obj, prop);
            if ((!type || !type.constructor))
                return;
            obj[prop] = obj[prop].map(item => item ? Object.assign(new type(item), item) : item);
            obj[prop].forEach(item => {
                if (item)
                    transform(item);
            });
        }
    });
}
exports.transform = transform;
function transformAndValidate(obj) {
    transform(obj);
    return exports.validate(obj);
}
exports.transformAndValidate = transformAndValidate;
