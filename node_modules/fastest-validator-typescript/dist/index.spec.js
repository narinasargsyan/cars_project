"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("../src/index");
describe("Schema", () => {
    it("Should default to not strict", () => {
        let Test = class Test {
        };
        Test = __decorate([
            index_1.Schema()
        ], Test);
        expect(index_1.getSchema(Test)).toEqual({ $$strict: false });
    });
    it("Should set strict", () => {
        let Test = class Test {
        };
        Test = __decorate([
            index_1.Schema(true)
        ], Test);
        expect(index_1.getSchema(Test)).toEqual({ $$strict: true });
    });
});
describe("Field", () => {
    it("Should not apply any defaults", () => {
        let Test = class Test {
        };
        __decorate([
            index_1.Field(),
            __metadata("design:type", String)
        ], Test.prototype, "prop", void 0);
        Test = __decorate([
            index_1.Schema()
        ], Test);
        expect(index_1.getSchema(Test)).toEqual({ $$strict: false, prop: {} });
    });
    it("Should apply passed options", () => {
        let Test = class Test {
        };
        __decorate([
            index_1.Field({ type: "string" }),
            __metadata("design:type", String)
        ], Test.prototype, "prop", void 0);
        Test = __decorate([
            index_1.Schema()
        ], Test);
        expect(index_1.getSchema(Test)).toEqual({ $$strict: false, prop: { type: "string" } });
    });
});
describe("String", () => {
    it("Should apply defaults", () => {
        let Test = class Test {
        };
        __decorate([
            index_1.String(),
            __metadata("design:type", String)
        ], Test.prototype, "prop", void 0);
        Test = __decorate([
            index_1.Schema()
        ], Test);
        expect(index_1.getSchema(Test)).toEqual({ $$strict: false, prop: { type: "string", empty: false } });
    });
    it("Should apply passed options", () => {
        let Test = class Test {
        };
        __decorate([
            index_1.String({ empty: true }),
            __metadata("design:type", String)
        ], Test.prototype, "prop", void 0);
        Test = __decorate([
            index_1.Schema()
        ], Test);
        expect(index_1.getSchema(Test)).toEqual({ $$strict: false, prop: { type: "string", empty: true } });
    });
});
describe("Boolean", () => {
    it("Should apply defaults", () => {
        let Test = class Test {
        };
        __decorate([
            index_1.Boolean(),
            __metadata("design:type", Boolean)
        ], Test.prototype, "prop", void 0);
        Test = __decorate([
            index_1.Schema()
        ], Test);
        expect(index_1.getSchema(Test)).toEqual({ $$strict: false, prop: { type: "boolean" } });
    });
    it("Should apply passed options", () => {
        let Test = class Test {
        };
        __decorate([
            index_1.Boolean({ optional: true }),
            __metadata("design:type", Boolean)
        ], Test.prototype, "prop", void 0);
        Test = __decorate([
            index_1.Schema()
        ], Test);
        expect(index_1.getSchema(Test)).toEqual({ $$strict: false, prop: { type: "boolean", optional: true } });
    });
});
describe("Number", () => {
    it("Should apply defaults", () => {
        let Test = class Test {
        };
        __decorate([
            index_1.Number(),
            __metadata("design:type", Number)
        ], Test.prototype, "prop", void 0);
        Test = __decorate([
            index_1.Schema()
        ], Test);
        expect(index_1.getSchema(Test)).toEqual({ $$strict: false, prop: { type: "number", convert: true } });
    });
    it("Should apply passed options", () => {
        let Test = class Test {
        };
        __decorate([
            index_1.Number({ convert: false }),
            __metadata("design:type", Number)
        ], Test.prototype, "prop", void 0);
        Test = __decorate([
            index_1.Schema()
        ], Test);
        expect(index_1.getSchema(Test)).toEqual({ $$strict: false, prop: { type: "number", convert: false } });
    });
});
describe("UUID", () => {
    it("Should apply defaults", () => {
        let Test = class Test {
        };
        __decorate([
            index_1.UUID(),
            __metadata("design:type", String)
        ], Test.prototype, "prop", void 0);
        Test = __decorate([
            index_1.Schema()
        ], Test);
        expect(index_1.getSchema(Test)).toEqual({ $$strict: false, prop: { type: "uuid" } });
    });
    it("Should apply passed options", () => {
        let Test = class Test {
        };
        __decorate([
            index_1.UUID({ optional: true }),
            __metadata("design:type", String)
        ], Test.prototype, "prop", void 0);
        Test = __decorate([
            index_1.Schema()
        ], Test);
        expect(index_1.getSchema(Test)).toEqual({ $$strict: false, prop: { type: "uuid", optional: true } });
    });
});
describe("ObjectId", () => {
    it("Should apply defaults", () => {
        let Test = class Test {
        };
        __decorate([
            index_1.ObjectId(),
            __metadata("design:type", String)
        ], Test.prototype, "prop", void 0);
        Test = __decorate([
            index_1.Schema()
        ], Test);
        expect(index_1.getSchema(Test)).toEqual({ $$strict: false, prop: { type: "string", pattern: expect.any(RegExp) } });
    });
    it("Should apply passed options", () => {
        let Test = class Test {
        };
        __decorate([
            index_1.ObjectId({ optional: true }),
            __metadata("design:type", String)
        ], Test.prototype, "prop", void 0);
        Test = __decorate([
            index_1.Schema()
        ], Test);
        expect(index_1.getSchema(Test)).toEqual({ $$strict: false, prop: { type: "string", pattern: expect.any(RegExp), optional: true } });
    });
});
describe("Email", () => {
    it("Should apply defaults", () => {
        let Test = class Test {
        };
        __decorate([
            index_1.Email(),
            __metadata("design:type", String)
        ], Test.prototype, "prop", void 0);
        Test = __decorate([
            index_1.Schema()
        ], Test);
        expect(index_1.getSchema(Test)).toEqual({ $$strict: false, prop: { type: "email" } });
    });
    it("Should apply passed options", () => {
        let Test = class Test {
        };
        __decorate([
            index_1.Email({ optional: true }),
            __metadata("design:type", String)
        ], Test.prototype, "prop", void 0);
        Test = __decorate([
            index_1.Schema()
        ], Test);
        expect(index_1.getSchema(Test)).toEqual({ $$strict: false, prop: { type: "email", optional: true } });
    });
});
describe("Date", () => {
    it("Should apply defaults", () => {
        let Test = class Test {
        };
        __decorate([
            index_1.Date(),
            __metadata("design:type", Object)
        ], Test.prototype, "prop", void 0);
        Test = __decorate([
            index_1.Schema()
        ], Test);
        expect(index_1.getSchema(Test)).toEqual({ $$strict: false, prop: { type: "date" } });
    });
    it("Should apply passed options", () => {
        let Test = class Test {
        };
        __decorate([
            index_1.Date({ convert: true }),
            __metadata("design:type", Object)
        ], Test.prototype, "prop", void 0);
        Test = __decorate([
            index_1.Schema()
        ], Test);
        expect(index_1.getSchema(Test)).toEqual({ $$strict: false, prop: { type: "date", convert: true } });
    });
});
describe("Enum", () => {
    it("Should apply defaults", () => {
        let Test = class Test {
        };
        __decorate([
            index_1.Enum(),
            __metadata("design:type", String)
        ], Test.prototype, "prop", void 0);
        Test = __decorate([
            index_1.Schema()
        ], Test);
        expect(index_1.getSchema(Test)).toEqual({ $$strict: false, prop: { type: "enum" } });
    });
    it("Should apply passed options", () => {
        let Test = class Test {
        };
        __decorate([
            index_1.Enum({ optional: true }),
            __metadata("design:type", String)
        ], Test.prototype, "prop", void 0);
        Test = __decorate([
            index_1.Schema()
        ], Test);
        expect(index_1.getSchema(Test)).toEqual({ $$strict: false, prop: { type: "enum", optional: true } });
    });
});
describe("Array", () => {
    it("Should apply defaults", () => {
        let Test = class Test {
        };
        __decorate([
            index_1.Array({ items: 'string' }),
            __metadata("design:type", String)
        ], Test.prototype, "prop", void 0);
        Test = __decorate([
            index_1.Schema()
        ], Test);
        const schema = index_1.getSchema(Test);
        expect(schema).toEqual({ $$strict: false, prop: { type: "array", items: "string", } });
    });
    it("Should apply passed options", () => {
        let Test = class Test {
        };
        __decorate([
            index_1.Array({ optional: true }),
            __metadata("design:type", String)
        ], Test.prototype, "prop", void 0);
        Test = __decorate([
            index_1.Schema()
        ], Test);
        expect(index_1.getSchema(Test)).toEqual({ $$strict: false, prop: { type: "array", optional: true } });
    });
});
describe("Nested", () => {
    it("Should apply defaults", () => {
        let Test = class Test {
        };
        __decorate([
            index_1.Nested(),
            __metadata("design:type", Object)
        ], Test.prototype, "prop", void 0);
        Test = __decorate([
            index_1.Schema()
        ], Test);
        expect(index_1.getSchema(Test)).toEqual({ $$strict: false, prop: { type: "object", strict: false, props: {} } });
    });
    it("Should apply nested schema", () => {
        let NestedTest = class NestedTest {
        };
        __decorate([
            index_1.Boolean(),
            __metadata("design:type", Boolean)
        ], NestedTest.prototype, "prop", void 0);
        NestedTest = __decorate([
            index_1.Schema(true)
        ], NestedTest);
        let Test = class Test {
        };
        __decorate([
            index_1.Nested(),
            __metadata("design:type", NestedTest)
        ], Test.prototype, "prop", void 0);
        Test = __decorate([
            index_1.Schema()
        ], Test);
        expect(index_1.getSchema(Test)).toEqual({
            $$strict: false, prop: {
                type: "object", strict: true, props: {
                    prop: { type: "boolean" }
                }
            }
        });
    });
    it("Should apply nested array schema", () => {
        let AnotherNested = class AnotherNested {
        };
        __decorate([
            index_1.Number({ positive: true, integer: true }),
            __metadata("design:type", Number)
        ], AnotherNested.prototype, "prop", void 0);
        AnotherNested = __decorate([
            index_1.Schema(true)
        ], AnotherNested);
        let NestedTest = class NestedTest {
        };
        __decorate([
            index_1.Nested(),
            __metadata("design:type", AnotherNested)
        ], NestedTest.prototype, "anotherNested", void 0);
        NestedTest = __decorate([
            index_1.Schema(true)
        ], NestedTest);
        let Test = class Test {
        };
        __decorate([
            index_1.NestedArray(NestedTest),
            __metadata("design:type", Array)
        ], Test.prototype, "prop", void 0);
        Test = __decorate([
            index_1.Schema()
        ], Test);
        expect(index_1.getSchema(Test)).toEqual({
            prop: {
                type: "array",
                strict: true,
                items: {
                    props: {
                        anotherNested: {
                            props: {
                                prop: {
                                    convert: true,
                                    positive: true,
                                    integer: true,
                                    type: "number"
                                }
                            }, strict: true, type: "object"
                        }
                    }, strict: true, type: "object"
                }
            }, $$strict: false
        });
    });
    it("Should not remove nested $$strict", () => {
        let NestedTest = class NestedTest {
        };
        __decorate([
            index_1.Boolean(),
            __metadata("design:type", Boolean)
        ], NestedTest.prototype, "prop", void 0);
        NestedTest = __decorate([
            index_1.Schema()
        ], NestedTest);
        let Test = class Test {
        };
        __decorate([
            index_1.Nested(),
            __metadata("design:type", NestedTest)
        ], Test.prototype, "prop", void 0);
        Test = __decorate([
            index_1.Schema()
        ], Test);
        expect(index_1.getSchema(NestedTest)).toEqual({
            $$strict: false,
            prop: { "type": "boolean" }
        });
    });
});
describe("Inheritance", () => {
    it("Should apply schema", () => {
        let BaseClass = class BaseClass {
        };
        __decorate([
            index_1.Boolean(),
            __metadata("design:type", Boolean)
        ], BaseClass.prototype, "propFromBaseClass", void 0);
        BaseClass = __decorate([
            index_1.Schema(true)
        ], BaseClass);
        let Child1 = class Child1 extends BaseClass {
        };
        __decorate([
            index_1.Number(),
            __metadata("design:type", Number)
        ], Child1.prototype, "propFromChild1", void 0);
        Child1 = __decorate([
            index_1.Schema()
        ], Child1);
        let Child2 = class Child2 extends BaseClass {
        };
        __decorate([
            index_1.Number(),
            __metadata("design:type", Number)
        ], Child2.prototype, "propFromChild2", void 0);
        __decorate([
            index_1.NestedArray(Child1),
            __metadata("design:type", Child1)
        ], Child2.prototype, "arrayOfChild1", void 0);
        Child2 = __decorate([
            index_1.Schema()
        ], Child2);
        expect(index_1.getSchema(Child2)).toEqual({
            propFromBaseClass: { type: "boolean" },
            $$strict: false,
            propFromChild2: { convert: true, type: "number" },
            arrayOfChild1: { type: "array", strict: false,
                items: { props: { propFromBaseClass: { type: "boolean" }, propFromChild1: { convert: true, type: "number" } },
                    strict: false, type: "object" } }
        });
    });
});
describe("validate", () => {
    it("Should throw an error if missing compiled validation method", () => {
        class Test {
        }
        expect(() => index_1.validate(new Test())).toThrow();
    });
    it("Should return true when valid", () => {
        let Test = class Test {
        };
        __decorate([
            index_1.Email(),
            __metadata("design:type", String)
        ], Test.prototype, "prop", void 0);
        Test = __decorate([
            index_1.Schema()
        ], Test);
        const t = new Test();
        t.prop = "test@test.com";
        expect(index_1.validate(t)).toEqual(true);
    });
    it("Should return true when valid with optional nested array", () => {
        let SomeNestedClass = class SomeNestedClass {
        };
        SomeNestedClass = __decorate([
            index_1.Schema()
        ], SomeNestedClass);
        let SomeClass = class SomeClass {
        };
        __decorate([
            index_1.NestedArray(SomeNestedClass, { optional: true }),
            __metadata("design:type", Array)
        ], SomeClass.prototype, "arrayOfNestedClass", void 0);
        SomeClass = __decorate([
            index_1.Schema()
        ], SomeClass);
        const t = new SomeClass();
        expect(index_1.validate(t)).toEqual(true);
    });
    it("Should return validation errors", () => {
        let Test = class Test {
        };
        __decorate([
            index_1.Email(),
            __metadata("design:type", String)
        ], Test.prototype, "prop", void 0);
        Test = __decorate([
            index_1.Schema()
        ], Test);
        const t = new Test();
        t.prop = "invalid";
        expect(index_1.validate(t)[0].field).toEqual("prop");
    });
});
describe("validateOrReject", () => {
    it("Should return true when valid", () => __awaiter(void 0, void 0, void 0, function* () {
        let Test = class Test {
        };
        __decorate([
            index_1.Email(),
            __metadata("design:type", String)
        ], Test.prototype, "prop", void 0);
        Test = __decorate([
            index_1.Schema()
        ], Test);
        const t = new Test();
        t.prop = "test@test.com";
        expect(yield index_1.validateOrReject(t)).toEqual(true);
    }));
    it("Should throw validation errors", () => __awaiter(void 0, void 0, void 0, function* () {
        let Test = class Test {
        };
        __decorate([
            index_1.Email(),
            __metadata("design:type", String)
        ], Test.prototype, "prop", void 0);
        Test = __decorate([
            index_1.Schema()
        ], Test);
        const t = new Test();
        t.prop = "invalid";
        expect.assertions(1);
        try {
            yield index_1.validateOrReject(t);
        }
        catch (e) {
            expect(e[0].field).toEqual("prop");
        }
    }));
});
describe("transform", () => {
    let AnotherNested = class AnotherNested {
        get total() { return 1; }
    };
    __decorate([
        index_1.Number({ positive: true, integer: true }),
        __metadata("design:type", Number)
    ], AnotherNested.prototype, "prop", void 0);
    AnotherNested = __decorate([
        index_1.Schema(true)
    ], AnotherNested);
    let NestedTest = class NestedTest {
        get total() { return 1; }
    };
    __decorate([
        index_1.Nested(),
        __metadata("design:type", AnotherNested)
    ], NestedTest.prototype, "anotherNested", void 0);
    NestedTest = __decorate([
        index_1.Schema(true)
    ], NestedTest);
    let Test = class Test {
        get total() { return 1; }
    };
    __decorate([
        index_1.NestedArray(NestedTest),
        __metadata("design:type", Array)
    ], Test.prototype, "prop", void 0);
    Test = __decorate([
        index_1.Schema()
    ], Test);
    it("Should instantiate object", () => {
        const obj = Object.assign(new Test(), { prop: [{ anotherNested: { prop: 1 } }] });
        index_1.transform(obj);
        expect(obj.total).toEqual(1);
        expect(obj.prop[0].total).toEqual(1);
        expect(obj.prop[0].anotherNested.total).toEqual(1);
    });
});
describe("transform and validate", () => {
    it("Should return true when valid", () => {
        let AnotherNestedObject = class AnotherNestedObject {
            get total() { return 1; }
        };
        __decorate([
            index_1.Number({ positive: true, integer: true }),
            __metadata("design:type", Number)
        ], AnotherNestedObject.prototype, "prop", void 0);
        AnotherNestedObject = __decorate([
            index_1.Schema(true)
        ], AnotherNestedObject);
        let NestedObject = class NestedObject {
            get total() { return 1; }
        };
        __decorate([
            index_1.Nested(),
            __metadata("design:type", AnotherNestedObject)
        ], NestedObject.prototype, "anotherNested", void 0);
        NestedObject = __decorate([
            index_1.Schema(true)
        ], NestedObject);
        let SomeModel = class SomeModel {
            get total() { return 1; }
        };
        __decorate([
            index_1.NestedArray(NestedObject),
            __metadata("design:type", Array)
        ], SomeModel.prototype, "prop", void 0);
        SomeModel = __decorate([
            index_1.Schema()
        ], SomeModel);
        const t = Object.assign(new SomeModel(), { prop: [{ anotherNested: { prop: 1 } }] });
        expect(index_1.transformAndValidate(t)).toEqual(true);
        expect(t.total).toEqual(1);
        expect(t.prop[0].total).toEqual(1);
        expect(t.prop[0].anotherNested.total).toEqual(1);
    });
    it("Should return validation errors", () => {
        let Test = class Test {
        };
        __decorate([
            index_1.Email(),
            __metadata("design:type", String)
        ], Test.prototype, "prop", void 0);
        Test = __decorate([
            index_1.Schema()
        ], Test);
        const t = new Test();
        t.prop = "invalid";
        expect(index_1.transformAndValidate(t)[0].field).toEqual("prop");
    });
});
