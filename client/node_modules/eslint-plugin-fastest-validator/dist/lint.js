"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rule = exports.createRule = void 0;
const experimental_utils_1 = require("@typescript-eslint/experimental-utils");
const typescript_estree_1 = require("@typescript-eslint/typescript-estree");
exports.createRule = experimental_utils_1.ESLintUtils.RuleCreator(_ => "");
function isPrimitiveType(type) {
    switch (type) {
        case typescript_estree_1.AST_NODE_TYPES.TSBooleanKeyword:
        case typescript_estree_1.AST_NODE_TYPES.TSNumberKeyword:
        case typescript_estree_1.AST_NODE_TYPES.TSStringKeyword:
            return true;
        default:
            return false;
    }
}
function isOptionalParam(node) {
    return "optional" in node && node.optional === true;
}
exports.rule = exports.createRule({
    name: "validation-decorators",
    meta: {
        type: "suggestion",
        docs: {
            description: "Requires using decorators for strongly type validation",
            category: "Stylistic Issues",
            recommended: false,
        },
        fixable: "code",
        messages: {
            errorMissingSchema: "missing Schema decorator.",
            errorMissingTypeValidation: "missing validation decorator.",
        },
        schema: [
            {
                type: "object"
            },
        ],
    },
    defaultOptions: [],
    create(context) {
        const handleType = (node, decoratorName, type) => {
            const prop = node;
            const hasBooleanDecorator = (prop === null || prop === void 0 ? void 0 : prop.decorators) && (prop === null || prop === void 0 ? void 0 : prop.decorators.some((d) => d.expression.callee.name === decoratorName));
            if (hasBooleanDecorator) {
                return;
            }
            context.report({
                node: prop,
                messageId: "errorMissingSchema",
                fix(fixer) {
                    const options = isOptionalParam(prop) ? "optional: true" : "";
                    const decoratorParams = (type ? type + (options ? ", " : "") : "") + (options ? `{${options}}` : "");
                    return [fixer.insertTextBefore(prop, `@${decoratorName}(${decoratorParams}) `)];
                },
            });
        };
        return {
            ClassDeclaration(node) {
                const decorators = node.decorators || [];
                const hasSchemaDecorator = decorators.some((d) => d.expression.callee.name === "Schema");
                if (hasSchemaDecorator) {
                    return;
                }
                context.report({
                    node: node,
                    messageId: "errorMissingTypeValidation",
                    fix(fixer) {
                        var _a;
                        return [fixer.insertTextBefore(((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === "ExportNamedDeclaration" ? node.parent : node, "@Schema()\n")];
                    },
                });
            },
            ClassProperty(node) {
                var _a, _b, _c, _d, _e, _f;
                const type = (_b = (_a = node.typeAnnotation) === null || _a === void 0 ? void 0 : _a.typeAnnotation) === null || _b === void 0 ? void 0 : _b.type;
                if (!type)
                    return;
                if (type === "TSTypeReference")
                    handleType(node, "Nested");
                else if (type === "TSArrayType") {
                    const t = (_f = (_e = (_d = (_c = node.typeAnnotation) === null || _c === void 0 ? void 0 : _c.typeAnnotation) === null || _d === void 0 ? void 0 : _d.elementType) === null || _e === void 0 ? void 0 : _e.typeName) === null || _f === void 0 ? void 0 : _f.name;
                    handleType(node, t ? "NestedArray" : "Array", t);
                }
                else if (isPrimitiveType(type))
                    handleType(node, type.replace("TS", "").replace("Keyword", ""));
            }
        };
    },
});
//# sourceMappingURL=lint.js.map